1. 栈的实现
请用顺序存储实现栈的数据结构Stack。你所实现的栈应包括：pop，push，top，size，clear，full等功能。利用你实现的Stack实现输入数字的逆序输出。
【输入】整数序列以-1结束，序列长度小于100
【输出】输入整数序列的逆序序列
例如：
【输入】3 9 8 2 5 -1 
【输出】5 2 8 9 3

======================================================================

2. 双栈的顺序实现
（双栈的顺序实现 P65 E4）双栈是指用一个数组模拟两个栈的实现，它可以避免程序包含两个栈时，一个栈数据量大发生溢出，而另外一个栈数据量少还有相当多未用空间的情况。双栈的实现时，数组的下标0和下标MAX-1分别为两个栈的栈底，入栈时两个栈的栈顶分别向数组中间位置移动。以这种方式，只有当栈顶相遇才会发生溢出，较好解决了两个栈的数据不均衡的问题。请用顺序存储实现数据结构DoubleStack，需要的功能有：push_a, push_b, pop_a, pop_b, top_a, top_b, full等。利用你实现的DoubleStack实现两行整数序列的逆序输出。
 
【输入】
整数序列A以-1结束，序列长度小于60
整数序列B以-1结束，序列长度小于60
【输出】
整数序列A的逆序
整数序列B的逆序
例如：
【输入】
3 9 8 2 5 -1 
2 3 4 5 6 -1
【输出】
5 2 8 9 3
6 5 4 3 2

======================================================================

3. 10以内的后序波兰式求解 
(10以内的后序波兰式求解) 请编写程序求解10以内的后序波兰式的值。
【输入】合法的10以内的后序波兰式
【输出】后序波兰式的值
例如：
【输入】23+6*
【输出】30

======================================================================

4. 任意进制的转换
编写程序实现10进制数向任意进制数的转换。
【输入】十进制数m  目标进制（2，8，16）
【输出】m转换成目标进制后的值
例如：
【输入】15 16
【输出】F
【输入】9 2
【输出】1001

======================================================================

5. 出入栈序列判断
假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，可以操作的序列称为称为合法序列，否则称为非法序列。
例如：
A.IOIIOIOO 合法 B.IOOIOIIO 不合法 
C.IIIOIOIO 合法 D.IIIOOIOO 合法
请写出一个算法，判断所给的操作序列是否合法。若合法，返回true，否则返回false
【输入】n n条I和O组成的序列(序列长度<=80)
【输出】n条序列的判断结果（true或者false）
例如：
【输入】
3
IOIIOIOO
IOOIOIIO
IIIOIOIO

【输出】
true
false
true

======================================================================

6. 程序代码中的括号匹配
（程序代码中的括号匹配）请编写程序对一段程序代码中的括号匹配情况进行判断。括号类型有（），[],{}三类，程序代码中可能包含注释,如多行注释/**/和单行注释//，且注释内容不参与括号匹配情况的分析。
【输入】 若干行程序代码，代码长度小于1500个字符
【输出】 除去注释后的括号数量 括号是否匹配（yes/no）
例如：
【输入】
int Collatz(unsigned int n) {
    if(n==1) return 0;
    else if(n%2) return Collatz(n*3+1)+1;
    else return Collatz(n/2)+1;
}
【输出】12 yes

【输入】
float CalcPay( /* [in] */  float  payRate,     // Employee's pay rate
              /* [in] */  float  hours      // Hours worked
               ){     //return Wages earned（）
【输出】 3 no

